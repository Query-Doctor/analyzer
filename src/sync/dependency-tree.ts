import { trace } from "@opentelemetry/api";
import { log } from "../log.ts";
import { withSpan } from "../otel.ts";
import { MaxTableIterationsReached } from "./errors.ts";

export type Dependency =
  // a source table with dependencies
  | {
    sourceTable: string;
    sourceSchema: string;
    sourceColumn: string[];
    referencedSchema: string;
    referencedTable: string;
    referencedColumn: string[];
  }
  // a source table with no dependencies
  | {
    sourceTable: string;
    sourceSchema: string;
    sourceColumn: null;
    referencedSchema: null;
    referencedTable: null;
    referencedColumn: null;
  };

/** A pointer from a current table context to another */
interface Pointer {
  fullyQualifiedSourceTable: string;
  fullyQualifiedReferencedTable: string;
  sourceColumn: string[];
  referencedColumn: string[];
}

declare const hashSymbol: unique symbol;
// TODO: don't export this symbol? But we need the connector to be
// able to construct a valid type for the hash
export type Hash = string & { [hashSymbol]: true };

export type Cursor<T> = AsyncGenerator<T, void, unknown>;

export type InsertableTuple = {
  table: string;
  data: NonNullable<Record<string, unknown>>;
  // hash: Hash;
};

/**
 * A message about the dependency analyzer's process that should be
 * returned to the user. These aren't show-stopping errors but things
 * an end-user should be aware of.
 */
export type DependencyResolutionNotice =
  | { kind: "incomplete_dependency_chain"; chain: string[]; table: string }
  | { kind: "too_few_rows"; table: string; requested: number; found: number };

export type TableRows<
  T extends Record<string, unknown> = Record<string, unknown>,
> = Record<FullyQualifiedTableName, T[]>;

export type FindAllDependenciesResult<
  T extends Record<string, unknown> = Record<string, unknown>,
> = {
  items: TableRows<T>;
  notices: DependencyResolutionNotice[];
};

export type CursorOptions = { requiredRows: number; seed: number };

export type DependenciesOptions = {
  excludedSchemas: string[];
};

export interface DatabaseConnector<
  T extends InsertableTuple = InsertableTuple,
> {
  cursor(
    fullyQualifiedTable: FullyQualifiedTableName,
    options: CursorOptions,
  ): Cursor<T>;
  dependencies(options: DependenciesOptions): Promise<Dependency[]>;
  get(
    fullyQualifiedSchema: FullyQualifiedTableName,
    values: Record<string, unknown>,
  ): Promise<T | undefined>;
  /** The unique value of the returned tuple */
  hash(value: T): Hash;
  /** Used to run stuff like `vacuum analyze` before the analysis begins */
  onStartAnalyze?(): Promise<void>;
}

export type DependencyAnalyzerOptions = {
  /**
   * The minimum number of rows to grab for each table.
   */
  requiredRows: number;
  /**
   * The maximum number of rows to allow for a single table.
   *
   * Because of the way dependency resolution works, it's possible to
   * follow a chain of FKs that include many rows from multiple tables
   * that exceed `requiredRows`. This option allows the analyzer to
   */
  maxRows: number;
  /**
   * Random seed for ensuring consistent random sampling.
   * @default 0
   */
  seed: number;
};

/**
 * The dependency analyzer is responsible for finding all dependencies for all tables in a database.
 *
 * One of the problems with restoring a sample of a database is that rows in tables tend to have
 * foreign keys that point to specific rows in other tables. So we can't just pick a bunch of rows
 * at complete random otherwise we'd end up with an inconsistent database.
 *
 * `DependencyAnalyzer` fixes this problem by taking a generic database connector, building a graph of
 * dependencies and traversing all the depedencies that are found in rows generated by the cursor
 * opened by the connector.
 */
export class DependencyAnalyzer<T extends InsertableTuple = InsertableTuple> {
  private readonly seen = new Set<Hash>();
  private static readonly MAX_TABLE_ITERATIONS = 100;
  constructor(
    private readonly connector: DatabaseConnector<T>,
    private readonly options: DependencyAnalyzerOptions,
  ) {}

  /**
   * @throws {MaxTableIterationsReached} - indicative of a bug in the code
   * @throws {Error} - unexpected errors
   */
  async findAllDependencies(
    graph: DependencyGraph,
  ): Promise<FindAllDependenciesResult<T["data"]>> {
    // no dependencies if the user doesn't want anything
    if (this.options.requiredRows === 0) {
      return { items: {}, notices: [] };
    }
    log.debug("Starting dependency resolution", "dependency-resolution");
    this.seen.clear();
    await this.connector.onStartAnalyze?.();

    const items: TableRows<T["data"]> = {};

    // open cursor on all available tables to have a greater chance at an even distribution
    const cursors: Record<FullyQualifiedTableName, Cursor<T>> = {};
    const remainingTables = Array.from(graph.keys());

    for (const source of remainingTables) {
      cursors[source] = this.connector.cursor(source, this.options);
      items[source] = [];
    }

    let stack: string[] = [];
    const removeTable = (i: number) => {
      if (remainingTables[i] === undefined) {
        log.error(
          `Attempted to remove table ${
            remainingTables[i]
          } but it was not found`,
          "dependency-resolution",
        );
        return;
      }
      const cursor = cursors[remainingTables[i]];
      // close the iterator to avoid leaking resources
      cursor?.return();
      delete cursors[remainingTables[i]];
      remainingTables.splice(i, 1);
    };
    const notices: DependencyResolutionNotice[] = [];
    // we want to loop over everything until we've satisfied all table requirements
    for (let i = 0; remainingTables.length > 0; i++) {
      // it's bad to have while(true) loops so this is a just in case
      if (i > DependencyAnalyzer.MAX_TABLE_ITERATIONS) {
        throw new MaxTableIterationsReached(i);
      }
      for (let i = remainingTables.length - 1; i >= 0; i--) {
        const table = remainingTables[i]!;
        const tableItems = items[table];
        if (tableItems === undefined) {
          log.error(
            `Attempted to access table ${table} but it was not found in the items map`,
            "dependency-resolution",
          );
          continue;
        }
        const rowCountSatisfied =
          tableItems.length >= this.options.requiredRows;

        if (rowCountSatisfied) {
          removeTable(i);
          break;
        }

        const cursor = cursors[table];
        if (!cursor) {
          throw new Error(`Cursor for ${table} not found`);
        }
        const span = trace.getActiveSpan();
        const iterator = await cursor.next();
        span?.addEvent("cursor.next");

        if (iterator.done) {
          log.debug(
            `Notice: Table \`${table}\` has fewer rows (${tableItems.length}) than the required (${this.options.requiredRows})`,
            "dependency-resolution",
          );
          notices.push({
            kind: "too_few_rows",
            table,
            requested: this.options.requiredRows,
            found: tableItems.length,
          });
          removeTable(i);
          continue;
        }
        const sourceValue = iterator.value;

        stack = [];
        const results = await this.traverseDependencyChain(
          graph,
          table,
          sourceValue,
        );
        for (const result of results) {
          const tableItems = items[result.table];
          if (tableItems === undefined) {
            log.error(
              `Attempted to access table ${result.table} but it was not found in the items map`,
              "dependency-resolution",
            );
            continue;
          }
          stack.push(result.table);
          const chainExceedsMaxRows = tableItems.length >= this.options.maxRows;
          // WARNING: BREAKING OUT OF THIS LOOP WILL RESULT IN AN INCONSISTENT DEPENDENCY STATE
          // The only reason this isn't an error is because it's _technically_ possible to restore
          // a database with internally inconsistent foreign key constraints.
          if (chainExceedsMaxRows) {
            log.warn(
              `Notice: Table \`${table}\` has more rows than the maximum ${this.options.maxRows}`,
              "dependency-resolution",
            );
            notices.push({
              kind: "incomplete_dependency_chain",
              chain: stack,
              table,
            });
            break;
          }
          tableItems.push(result.data);
        }
        const hashed = this.connector.hash(sourceValue);
        if (!this.seen.has(hashed)) {
          const tableItems = items[table];
          if (tableItems === undefined) {
            log.error(
              `Attempted to access table ${table} but it was not found in the items map`,
              "dependency-resolution",
            );
            continue;
          }
          tableItems.push(sourceValue.data);
          this.seen.add(hashed);
        }
      }
    }
    log.info(
      `Found ${Object.keys(items).length} tables with ${
        Object.values(
          items,
        ).reduce((acc, table) => acc + table.length, 0)
      } rows`,
      "dependency-resolution",
    );
    return { items, notices };
  }

  /**
   * Generates a chain of all dependencies for a given source node.
   */
  async traverseDependencyChain(
    graph: DependencyGraph,
    sourceTable: FullyQualifiedTableName,
    value: T,
  ): Promise<T[]> {
    const table = graph.get(sourceTable);
    if (!table) {
      throw new Error(
        `Table not declared in dependency graph. The graph should include a key for all existing tables in a database, even if they have no dependencies`,
      );
    }
    function valuesFor(
      pointer: Pointer,
    ):
      | { ok: false; column: string[] }
      | { ok: true; params: Record<string, unknown> } {
      const params: Record<string, unknown> = {};
      // source and referenced columns match by index
      for (let i = 0; i < pointer.sourceColumn.length; i++) {
        const source = pointer.sourceColumn[i]!;
        const reference = pointer.referencedColumn[i]!;
        // if any column of a foreign key is null, we don't follow the dependency
        if (
          value.data == null ||
          !(source in value.data) ||
          value.data[source] == null
        ) {
          return { ok: false, column: pointer.sourceColumn };
        }
        params[reference] = value.data[source];
      }
      return { ok: true, params };
    }

    const results: T[] = [];
    for (const dep of table) {
      const values = valuesFor(dep);
      const fullyReferencesOtherRow = values.ok;
      // sometimes the FK is null and there isn't a corresponding row in the other table.
      // This is totally fine and doesn't deserve to be logged as an error.
      if (!fullyReferencesOtherRow) {
        continue;
      }
      const referenced = await this.connector.get(
        dep.fullyQualifiedReferencedTable,
        values.params,
      );
      if (!referenced) {
        throw new Error(
          `Found an existing FK requirement but there was no corresponding row in ${dep.fullyQualifiedReferencedTable}. Is the database in a consistent state?`,
        );
      }
      const hashed = this.connector.hash(referenced);
      if (this.seen.has(hashed)) {
        continue;
      }
      this.seen.add(hashed);
      results.push(referenced);
      const next = await this.traverseDependencyChain(
        graph,
        dep.fullyQualifiedReferencedTable,
        referenced,
      );
      results.push(...next);
    }
    return results;
  }

  buildGraph(dependencies: Dependency[]): Promise<DependencyGraph> {
    return withSpan("buildGraph", () => {
      const graph = new Map<FullyQualifiedTableName, Pointer[]>();
      for (const dependency of dependencies) {
        const existing = graph.get(dependency.sourceTable) ?? [];
        // these fields are all quoted if necessary
        const fullyQualifiedSourceTable: FullyQualifiedTableName =
          `${dependency.sourceSchema}.${dependency.sourceTable}`;
        const fullyQualifiedReferencedTable: FullyQualifiedTableName =
          `${dependency.referencedSchema}.${dependency.referencedTable}`;

        if (dependency.sourceColumn) {
          existing.push({
            fullyQualifiedSourceTable,
            sourceColumn: dependency.sourceColumn,
            fullyQualifiedReferencedTable,
            referencedColumn: dependency.referencedColumn,
          });
        }
        graph.set(
          fullyQualifiedSourceTable,
          existing,
        );
      }
      return graph;
    })();
  }
}

export type FullyQualifiedTableName = string;

type DependencyGraph = Map<FullyQualifiedTableName, Pointer[]>;
